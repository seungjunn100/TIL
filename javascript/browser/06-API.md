사이트 주소 = ip 주소 = 도메인 주소(naver.com)

안정성이 높은, 신뢰성이 중요한 통신에는 TCP 기반 프로토콜을 사용
게임은 거의 TCP 기반
데이터를 주고받을 때 수시로 확인

HTTP는 일회성 통신을 함, 이전 상태를 기억하지 못함, 이전 메모리를 버림
그래서 필요한 정보를 보낼 때 한번에 같이 보내야 한다.

q=0.9 선호도, 우선순위

Referer 유입 경로 확인

Response - 응답 바디

Response 메시지 구조
pc에서 스마트폰 모드에서 네이버를 접속했을 때 리디렉션

Accept-Ranges: bytes
클라이언트가 Range: bytes=1000-1999 형식으로 바이트 단위의 범위 요청 가능
스크롤시 부분적으로 렌더링할 수 있다?

api 프론트와 백엔드의 연결고리
api는 백엔드가 만든다.

API를 사용할땐
URL, Method를 확인 잘하기

"ok": 1, - 성공
"ok": 0, - 실패

포스트맨을 왜 사용하는걸까
포스트맨은 통신하는걸 UI적으로 확인하기 편하게 해준다.
백엔드가 만든 API를 통해 서버 통신을 하는 방법을 보기위해..?

Ajax
a 앵커태그를 이용해 페이지를 옮길 때 기사의 내용만 바뀌고 나머지 부분은 바뀌지가 않을땐 내용만 바꾸는게 효율적이다.. 그게 아니라면 페이지를 옮길 때 매번 똑같은 부분도 다시 다운로드 받고하면 요청도 많고 서버용량?도 많이 사용하게 된다.
- 페이지 이동이나 새로고침 없이 서버에 요청을 보내고 DOM API를 이용해 화면을 갱신

open 메서드 async false - send(data)는 동기가 됨
async true - send(data)는 비동기가 됨

XMLHttpRequest는 Promise 나오기 전에 나와 비동기는 콜백방식으로 사용해야함

xhr.open('get', url, false); // 네트워크에서 쓰로틀링을 활용해 비교해보자
동기방식은 이미지 요청을 누르고 나서 다른 작업을 하려고 이벤트를 실행하면 이미지를 요청받아서 이미지를 로드하는 실행이 끝난 뒤에 다음 이벤트가 진행이된다.
xhr.open('get', url, true); // 네트워크에서 쓰로틀링을 활용해 비교해보자
비동기 방식은 이미지 요청을 누르고 나서 다음 이벤트를 예약해놓을 수 있다.

axios
npm init -y
npm i axios
"moduleResolution": "bundler", // import시 모듈 해석 방식 지정 (node_modules 폴더에서 검색)

투두리스트 타입ts - 투두리스트 API 비교해보면서 확인