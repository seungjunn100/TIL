# Custom Hook

- [Custom Hook](#custom-hook-1)
- [사용 예시](#사용-예시)
  - [Counter 예제](#counter-예제)
  - [Fetch 예제](#fetch-예제)




<br />
<br />




## Custom Hook

리액트의 기본 훅(`useState`, `useEffect` 등)을 이용해 특정 로직을 여러 컴포넌트에서 재사용 가능하게 만드는 커스텀 훅

- 함수 이름은 반드시 `use*` 형태로 작성해야 한다.

- 리액트의 기본 훅은 일반 함수에서 사용할 수 없다.
  
  - 기본 훅을 활용하려면 커스텀 훅으로 작성해야 한다.

- UI와 비즈니스 로직을 분리하여 컴포넌트를 단순화 할 수 있다.

- 상태, 효과 관련 로직을 묶어서 컴포넌트 단위의 유지보수가 용이하다.

<br />

## 사용 예시

### Counter 예제

#### Counter 컴포넌트

```tsx
import Button from "@/components/Button";
import { useState } from "react";

interface CounterProps {
  children: string;
}

function Counter({ children }: CounterProps) {
  console.log('\tCounter 호출됨.');

  const initCount = Number(children);

  const [ count, setCount ] = useState(initCount);

  const [ step, setStep ] = useState(1);

  // 카운트 감소
  const handleDown = () => {
    setCount(count - step);
  };

  // 카운트 증가
  const handleUp = () => {
    setCount(count + step);
  };

  // 카운트 초기화
  const handleReset = () => {
    setCount(initCount);
  };

  return (
    <div id="counter">
      <label htmlFor="step">증감치</label>
      <input id="step" type="number" value={ step } onChange={ (e) => setStep(Number(e.target.value)) } />
      <Button bgColor="red" color="black" onClick={ handleDown }>-_-</Button>
      <Button bgColor="gray" onClick={ handleReset }>0_0</Button>
      <Button onClick={ handleUp }>+_+</Button>
      <span>{ count }</span>
    </div>
  );
}

export default Counter;
```

- 상태 관련 로직을 따로 분리해서 작업하여 용이하게 관리할 수 있다.

<br />

#### useCounter 커스텀 훅

```tsx
import { useState } from "react";

function useCounter(initCount: number) {
  const [ count, setCount ] = useState(initCount);
  const [ step, setStep ] = useState(1);

  const handleStepChange = (newStep: number) => {
    setStep(newStep);
  };

  // 카운트 감소
  const handleDown = () => {
    setCount(count - step);
  };

  // 카운트 증가
  const handleUp = () => {
    setCount(count + step);
  };

  // 카운트 초기화
  const handleReset = () => {
    setCount(initCount);
  };

  return { count, step, handleStepChange, handleDown, handleUp, handleReset };
}

export default useCounter;
```

- 상태 관련 로직을 커스텀 훅에 모아두었다.

<br />

#### useCounter 커스텀 훅을 사용하는 Counter 컴포넌트

```tsx
import Button from "@/components/Button";
import useCounter from "@/hooks/useCounter";

interface CounterProps {
  children: string;
}

function Counter({ children }: CounterProps) {
  console.log('\tCounter 호출됨.');

  const initCount = Number(children);

  const { 
    count, 
    step, 
    handleStepChange, 
    handleDown, 
    handleUp, 
    handleReset 
  } = useCounter(initCount);

  return (
    <div id="counter">
      <label htmlFor="step">증감치</label>
      <input id="step" type="number" value={ step } onChange={ (e) => handleStepChange(Number(e.target.value)) } />
      <Button bgColor="red" color="black" onClick={ handleDown }>-_-</Button>
      <Button bgColor="gray" onClick={ handleReset }>0_0</Button>
      <Button onClick={ handleUp }>+_+</Button>
      <span>{ count }</span>
    </div>
  );
}

export default Counter;
```

- `Counter` 컴포넌트는 커스텀 훅을 사용하여 `props`를 전달받아 UI 작업에만 집중할 수 있다.




<br />
<br />




### Fetch 예제

![Custom-Fetch-1](../src/images/custom-fetch-1.png)

- 할일 목록과 할일 상세 조회 컴포넌트를 만들고, 
  
  - `useFetch` 커스텀 훅을 만들어 각 컴포넌트에서 사용
  
  - 할일 목록에서 링크 클릭 시 해당 할일의 상세 조회를 렌더링 하는 작업

#### useFetch 커스텀 훅

```typescript
import type { ErrorRes, ResData, TodoListRes, TodoInfoRes } from "@/types/todo";
import { useEffect, useState } from "react";

const API_SERVER = 'https://fesp-api.koyeb.app/todo';

interface FetchParams {
  url: string;
  // method?: string;
  method?: 'GET' | 'POST';
}

function useFetch<T extends TodoListRes | TodoInfoRes>(fetchParams: FetchParams) {
  console.log('2. useFetch 동작\n\t8. 리렌더링에 의해 useFetch 다시 동작');
  // Todo 목록을 저장할 상태 (초기값: null)
  const [ data, setData ] = useState<T | null>(null);

  // 에러 메세지를 저장할 상태 (초기값: null)
  const [ error, setError ] = useState<ErrorRes | null>(null);

  // 로딩 상태를 저장 (초기값: true)
  const [ loading, setLoading ] = useState(true);

  const requestFetch = async (params: FetchParams) => {
    console.log('5. requestFetch 동작');
    try{
      // 로딩중 상태 표시
      setLoading(true);

      const res = await fetch(API_SERVER + params.url); // fetch는 Promise를 반환해준다.
      // console.log('res', res);

      const jsonRes: ResData<T> = await res.json();
      // console.log('body', jsonRes);

      if (jsonRes.ok === 1) { // 타입 가드로 인해 타입을 TodoListRes | null 이 중에 TodoListRes 타입이 좁혀지게 된다.
        setData(jsonRes);
        setError(null);
      } else { // API 서버에서 에러를 응답 받을 경우(4xx, 5xx 에러)
        // setError(jsonRes);
        throw new Error(jsonRes.message);
      }
      console.log('6. API 요청하여 변경된 상태값을 비교하여 리렌더링 준비 및 상태값 갱신');
    }catch(err){
      // console.error((err as Error).message);
      // setError(err); // err의 unknown 타입은 타입 가드가 필요하다.
      // 네트워크 오류 같은 에러 발생 시
      setError(err as ErrorRes);
      setData(null);
    }finally{
      setLoading(false); // 데이터를 받아오거나 에러 메세지를 받아오거나 로딩은 끝난 상태
    }
  };

  // 컴포넌트가 마운트 된 후에 실행 // return된 후에 작업이 된다.
  useEffect(() => {
    console.log('4. 초기값으로 마운트된 후 useEffect 동작 requestFetch 실행');
    requestFetch(fetchParams);
  }, []); // 빈 배열을 전달해서 마운트시 한번만 호출되도록 설정

  return { data, error, loading };
}

export default useFetch;
```