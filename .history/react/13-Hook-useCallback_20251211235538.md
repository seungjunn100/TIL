# useCallback(feat. React.memo)

- [React.memo](#reactmemo)
- [useCallback](#usecallback)




<br />
<br />




## React.memo

`props`가 자주 변경되지 않는 컴포넌트는 메모이제이션하면, 불필요한 리렌더링을 방지할 수 있다.

![useCallback-1](../src/images/useCallback-1.png)

- 수량을 선택하게되면 모든 컴포넌트들이 리렌더링된다.

![useCallback-2](../src/images/useCallback-2.png)

- 컴포넌트 결과에 `React.memo`를 사용하면 리렌더링될 때 캐싱된 컴포넌트를 불러와 사용할 수 있다.

- 컴포넌트를 메모이제이션하여 불필요한 리렌더링을 방지할 수 있다.




<br />
<br />




## useCallback

함수를 메모이제이션해서 컴포넌트가 다시 렌더링되더라도 새로 생성되지 않고 캐싱된 함수를 사용하도록하는 훅

```tsx
const cachedFn = useCallback(fn, dependencies);
```

- `fn` : 캐싱할 함수

- `dependencies` : 의존성 배열

  - 캐싱할 함수 안에서 컴포넌트 내부의 변수를 사용할 경우, 캐싱할 함수 생성 시점에는 그 변수 값을 기억하게 된다.
    
    - 하지만, 변수가 바뀌면 함수를 새로 만들어야 하기 때문에, 그 변수를 의존성 배열에 넣어서 변경될 때마다 함수가 재생성되도록 해줘야 한다.

  - 빈 배열을 지정하면 처음 렌더링할 때 딱 한 번만 함수가 생성된다.
    
    - 이 때 생성된 함수가 캐싱되어 렌더링되어도 초기에 캐싱된 함수를 반환한다.

- 최초에는 캐싱할 함수를 반환하고, 

  - 다음 렌더링부터는 `dependencies`가 변하면 새로 생성된 함수를 반환하고, 
  
    - `dependencies`가 변하지 않으면 캐싱된 함수를 반환한다.

<br />

## React.memo를 이용한 useCallback 사용 예시

![useCallback-3](../src/images/useCallback-3.png)
![useCallback-4](../src/images/useCallback-4.png)

- `Shipping` 컴포넌트를 `React.memo`를 해주었지만 리렌더링이 발생한다.

  - `React.memo`의 기본 동작은 메모이제이션을 해주어도 `props`가 변경되면 리렌더링이 되는 구조를 갖고있다.

- 그래서 `Shipping` 컴포넌트의 `Props`는 변경되어 리렌더링이 되었지만, `UI`는 변경되지 않았다.

- 이런 불필요한 리렌더링을 피하기 위해 연산될 수 있는 작업들은 부모