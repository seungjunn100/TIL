# useCallback(feat. React.memo)

- [React.memo](#reactmemo)
- [useCallback](#usecallback)
- [React.memo를 이용한 useCallback 사용 예시](#reactmemo를-이용한-usecallback-사용-예시)




<br />
<br />




## React.memo

`props`가 자주 변경되지 않는 컴포넌트는 메모이제이션하면, 불필요한 리렌더링을 방지할 수 있다.

![useCallback-1](../src/images/useCallback-1.png)

- 수량을 선택하게되면 모든 컴포넌트들이 리렌더링된다.

![useCallback-2](../src/images/useCallback-2.png)

- 컴포넌트 결과에 `React.memo`를 사용하면 리렌더링될 때 캐싱된 컴포넌트를 불러와 사용할 수 있다.

- 컴포넌트를 메모이제이션하여 불필요한 리렌더링을 방지할 수 있다.




<br />
<br />




## useCallback

함수를 메모이제이션해서 컴포넌트가 다시 렌더링되더라도 새로 생성되지 않고 캐싱된 함수를 사용하도록하는 훅

```tsx
const cachedFn = useCallback(fn, dependencies);
```

- `fn` : 캐싱할 함수

- `dependencies` : 의존성 배열

  - 캐싱할 함수 안에서 컴포넌트 내부의 변수를 사용할 경우, 캐싱할 함수 생성 시점에는 그 변수 값을 기억하게 된다.
    
    - 하지만, 변수가 바뀌면 함수를 새로 만들어야 하기 때문에, 그 변수를 의존성 배열에 넣어서 변경될 때마다 함수가 재생성되도록 해줘야 한다.

  - 빈 배열을 지정하면 처음 렌더링할 때 딱 한 번만 함수가 생성된다.
    
    - 이 때 생성된 함수가 캐싱되어 렌더링되어도 초기에 캐싱된 함수를 반환한다.

- 최초에는 캐싱할 함수를 반환하고, 

  - 다음 렌더링부터는 `dependencies`가 변하면 새로 생성된 함수를 반환하고, 
  
    - `dependencies`가 변하지 않으면 캐싱된 함수를 반환한다.




<br />
<br />




## React.memo를 이용한 useCallback 사용 예시

![useCallback-3](../src/images/useCallback-3.png)

![useCallback-4](../src/images/useCallback-4.png)

- `Shipping` 컴포넌트를 `React.memo`를 해주었지만 리렌더링이 발생한다.

  - `React.memo`의 기본 동작은 메모이제이션을 해주어도 `props`가 변경되면 리렌더링이 되는 구조를 갖고있다.

- 그래서 `Shipping` 컴포넌트의 `props`는 변경되어 리렌더링이 되었지만, `UI`는 변경되지 않았다.

- 부모 컴포넌트가 리렌더링될 때마다 `props`를 자식 컴포넌트에 전달하여 자식 컴포넌트도 리렌더링이 발생하는 작업을 최소화 해주어야 한다.

![useCallback-5](../src/images/useCallback-5.png)

- `fees` 요금은 수량이 6개가 되어야 바뀌므로 그 전까지 `Shipping` 컴포넌트는 캐싱된 컴포넌트를 사용하고, 
  
  - `fees`가 바뀌면 `props`가 바뀌었으므로 리렌더링이 된다.

- 하지만, 수량이 바뀔 때마다 리렌더링이 발생한다.

  - 그 이유는 부모 컴포넌트가 리렌더링 되면 함수들의 참조 주소값은 매번 바뀌게 되며, 
    
    - 매번 바뀐 상태로 자식 컴포넌트에 전달이 되어 `props`가 변경 되어 리렌더링이 발생하게 된다.

- 이를 해결 하기 위해 사용하는게 `useCallback` 훅이다.

```tsx
...

const handlePayment = useCallback(() => {
  alert(`배송비 ${shippingPrice.toLocaleString()}원이 추가됩니다. 결제하시겠습니까?`);
}, []);

...
```

- `handlePayment` 함수를 `useCallback` 함수로 만들어 주면 함수에 의한 불필요한 리렌더링까지 작업하여 성능 최적화를 할 수 있다.

- 하지만 의존성 배열이 빈 배열을 지정하여 초기에 캐싱된 함수만 매번 반환하게 된다.
  
  - 이벤트가 동작할 시 초기에 캐싱된 함수를 실행하게 된다. 

  - 그래서 `shippingPrice`의 값이 올라도 초기에 캐싱된 함수의 `shippingPrice` 값으로 렌더링을 하기 때문에 문제가 발생한다.

    - 이렇게 함수가 만들어질 당시의 스코프를 기억하는 것은 클로저의 특징이다.

```tsx
...

const handlePayment = useCallback(() => {
  alert(`배송비 ${shippingPrice.toLocaleString()}원이 추가됩니다. 결제하시겠습니까?`);
}, [ shippingPrice ]);

...
```

- 그래서 `shippingPrice` 값이 바뀌면 해당 함수도 리렌더링 될 때 새로운 함수를 생성하여 반환할 수 있도록, 
  
  - `shippingPrice` 값을 의존성 배열에 지정해주어야 한다.




<br />
<br />




## 