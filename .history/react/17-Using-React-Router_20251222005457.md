# 리액트 라우터 사용 방법

- [리액트 라우터가 제공하는 라우터](#리액트-라우터가-제공하는-라우터)
  - [createBrowserRouter](#createbrowserrouter)
  - [createHashRouter](#createhashrouter)
  - [MemoryRouter](#memoryrouter)
- [리액트 라우터가 제공하는 주요 컴포넌트](#리액트-라우터가-제공하는-주요-컴포넌트)
  - [Link](#link)
  - [NavLink](#navlink)
  - [Outlet](#outlet)
  - [Navigate](#navigate)
- [리액트 라우터가 제공하는 주요 기능](#리액트-라우터가-제공하는-주요-기능)
  - [동적 세그먼트](#동적-세그먼트)
  - [중첩 라우트](#중첩-라우트)
  - [index 라우트](#index-라우트)
  - [에러 처리 전용 라우트](#에러-처리-전용-라우트)
- [리액트 라우터가 제공하는 주요 Hook]()




<br />
<br />




## 리액트 라우터가 제공하는 라우터

### createBrowserRouter

- 브라우저의 `History API`를 사용해서 `URL`과 화면(`UI`)을 직접 동기화한다.

- 브라우저의 `history` 스택 관리로 이전, 다음 페이지 이동 가능하다.

- 서버에는 `/page1`, `/page2` 같은 `HTML` 파일이 없기 때문에,
  
  - 어떤 `URL`로 요청이 와도 항상 `index.html`을 내려주는 서버 설정이 필요하다.
  
    - 서버 설정이 없을 때, `http://example.com/page1` 주소로 바로 진입을 하려고하면, 페이지가 안뜨는게 정상이다.
    
    - 하지만, `Vite`같은 개발 서버에서는 `fallback` 설정이 이미 내장되어 있어 `index.html`을 응답한다.
    
    - 개발 서버가 아닌 배포했을 때는 직접 파일을 요청하기 때문에 파일이 없으면 `404` 에러가 발생하여 접근하지 못한다.
      
      - 그래서 설정이 필요하다.

- 일반 웹 애플리케이션에서 가장 많이 사용된다.

![createBrowserRouter](../src/images/createBrowserRouter.png)

- `routes.tsx`에서 라우터가 어떻게 동작해야 하는지 정의둔다.

- `App.tsx`에서 `RouterProvider`는 라우터를 리액트 앱에 연결해주는 역할을 한다.

  - 라우팅이 동작되며, 현재 `URL`을 보고 어떤 라우트를 렌더링할지 이 라우터가 결정한다.

<br />

### createHashRouter

- `URL`에 `#(hash)`를 붙여 라우팅한다.

  - `http://example.com/#/home`

- `#` 뒤의 값은 서버로 전달되지 않기 때문에 브라우저가 서버에 요청하는 URL은 항상 `/`이다.

  - 그래서 어떤 `URL`로 요청이 와도 서버는 무조건 `index.html`을 내려준다.

    - `http://example.com/page1` 주소로 바로 진입을 하면, `index.html`을 응답받아 리액트가 실행되어 `#/page1`을 읽고 화면을 렌더링한다.

![createBrowserRouter](../src/images/createHashRouter.png)

<br />

### MemoryRouter

- 라우팅 정보를 메모리 안에서만 관리한다.

- 주소창 `URL`은 바뀌지 않고 항상 초기 페이지처럼 보인다.

- 브라우저의 이전, 다음 버튼도 의미가 없다.

- `history` 정보가 필요 없는 환경에서 사용된다.

  - `React Native`, 하이브리드 앱 등에서 사용된다.




<br />
<br />




## 리액트 라우터가 제공하는 주요 컴포넌트

### Link

- 페이지 새로고침 없이 경로를 이동하는 컴포넌트이며, `<a>` 태그를 대체한다.

- 주요 속성

  - `to` : 이동할 경로를 지정한다.

  - `replace`? : `true`로 설정하면 새 히스토리 항목을 추가하지 않고, 현재 히스토리 항목을 교체한다.
  
    - 즉, 이동은 하지만 방문 기록은 쌓이지 않는다.
    
    - 뒤로가기 시 이전 페이지로 돌아가지 않는다.
  
  - `state`?: 이동할 컴포넌트에 추가하여 데이터를 전달할 수 있다.
  
    - 이동한 컴포넌트에서 `useLocation` 훅을 통해 접근할 수 있다.

```jsx
function Header() {
  return (
    <header>
      <Link className="menu-dark" to="/home">home</Link> <br />
      <Link className="menu" to="/page1">page1</Link> <br />
      <Link className="menu" to="/page2">page2</Link>
    </header>
  );
}
```

<br />

### NavLink

- `Link`의 확장 버전으로 `className`, `style` 속성에 함수 정의가 가능하다.

- 해당 함수의 매개변수로 객체가 전달되고, 객체의 `isActive` 속성 값에는
  
  - 현재 URL과 `<NavLink>`의 `to` 속성이 일치하는 경우 `true`, 일치하지 않으면 `false`가 전달된다.
  
  - 매칭 여부에 따라 활성화된 메뉴 강조, 선택된 네비게인션 등 스타일 적용이 가능하다.

```jsx
function Header() {
  return (
    <header>
      <NavLink className={({ isActive }) => isActive ? 'menu-dark' : 'menu'} to="/home">home</NavLink> <br />
      <NavLink className={({ isActive }) => isActive ? 'menu-dark' : 'menu'} to="/page1">page1</NavLink> <br />
      <NavLink className={({ isActive }) => isActive ? 'menu-dark' : 'menu'} to="/page2">page2</NavLink>
    </header>
  );
}
```

<br />

### Outlet

- 중첩 라우트를 어느 위치에 렌더링할지 지정하는 컴포넌트이다.

- `context` 속성을 통해 자식 컴포넌트에 데이터를 전달할 수 있다.

![공통 컴포넌트](../src/images/Outlet-1.png)

- 중첩되는 `<Header />` 컴포넌트를 하나의 컴포넌트로 만들어 사용할 것이다.

![Layout 컴포넌트](../src/images/Outlet-2.png)

- 중첩되는 컴포넌트를 포함하는 새로운 부모 컴포넌트인 `<Layout />`을 생성한다.

- 최초 렌더링시 `<Layout />` 컴포넌트가 렌더링되고,

  - `<Outlet />` 컴포넌트에 의해 URL 경로에 따라 매칭되는 자식 컴포넌트를 렌더링하게 된다.


<br />

### Navigate

- 요청한 URL 대신 다른 경로로 이동시킬 경우 `<Navigate>` 컴포넌트 사용

- `replace` 속성을 `true`로 설정하면 새 히스토리 항목을 추가하지 않고, 현재 히스토리 항목을 교체한다.

```jsx
const router = createBrowserRouter([
  { 
    path: '/', 
    element: <Layout />, 
    children: [
      { path: '/', element: <Navigate to='/home' /> },
      { path: '/home', element: <Home /> },
      { path: '/page1', element: <Page1 /> },
      { path: '/page2', element: <Page2 /> }
    ],
  },
]);
```

- `http://localhost:5173/` 경로가 없는 페이지로 들어오면 `home` 페이지로 이동시킬 수 있다.

```jsx
const router = createBrowserRouter([
  { 
    path: '/', 
    element: <Layout />, 
    children: [
      { path: '/', element: <Home /> },
      { path: '/home', element: <Navigate to='/' /> },
      { path: '/page1', element: <Page1 /> },
      { path: '/page2', element: <Page2 /> }
    ],
  },
]);
```

- 반대로 `home`으로 갔을 때 경로가 없는 페이지로 이동시킬 수도 있다.




<br />
<br />




## 리액트 라우터가 제공하는 주요 기능

### 동적 세그먼트

- `URL` 경로에 동적인 값이 포함될 때 사용

- 경로에 `:파라미터명` 형태로 지정하면 `useParams` 훅을 사용하여 `URL` 파라미터 값을 가져올 수 있다.
  
  - 모든 값은 `string` 타입이므로 숫자나 다른 타입이 필요한 경우 변환 필요하다.

![동적 세그먼트 - 1](../src/images/dynamic-segment-1.png)

- 해당 리스트의 링크로 이동하기 위해 `id` 값을 추가하였다.

  - 하지만 해당 링크를 라우터에 정의해주지 않으면 `404` 에러가 발생한다.

![동적 세그먼트 - 2](../src/images/dynamic-segment-2.png)

- 링크를 클릭하면 `TodoInfo` 컴포넌트로 이동해야 한다. 

  - 해당 `id` 값이 필요한 컴포넌트의 경로에 동적 세그먼트를 지정하면 해당 페이지로 이동이 가능하게 된다.

![동적 세그먼트 - 3](../src/images/dynamic-segment-3.png)

- `useParams` 훅을 사용하여 해당 컴포넌트에서 `id` 값을 받아올 수 있다.

<br />

### 중첩 라우트

- 라우트 설정에서 `children` 속성으로 부모-자식 라우트를 구성하는 방식이다.

  - 위의 `Outlet` 컴포넌트와 같은 방식이다.

![중첩 라우트 - 1](../src/images/nested-route-1.png)

- 해당 `id` 값에 따른 `TodoInfo` 컴포넌트가 렌더링 되고 수정 버튼을 누르면, 
  
  - `TodoEdit` 컴포넌트가 렌더링된다.
    
    - 이 컴포넌트에 들어있는 내용은 `TodoInfo` 컴포넌트와 동일한 정보가 들어가게된다.
  
  - 그래서 `TodoEdit` 컴포넌트를 `TodoInfo` 컴포넌트의 자식 라우트로 정의하여 중첩된 라우트를 하나로 관리할 수 있다.

![중첩 라우트 - 2](../src/images/nested-route-2.png)

- 라우트 설정에서 `children` 속성으로 `TodoEdit` 컴포넌트를 `TodoInfo` 컴포넌트의 자식 라우트로 정의한다.

![중첩 라우트 - 3](../src/images/nested-route-3.png)

- 예를 들어, `list/3` 요청 시 `TodoInfo`가 렌더링되고, 수정 링크를 클릭하면 주소가 `list/3/edit`로 변경되며 `Outlet` 컴포넌트 영역에 `TodoEdit` 컴포넌트가 추가로 렌더링 된다.

<br />

### index 라우트

- `URL`이 부모 라우트의 `URL`과 일치할 경우 기본으로 렌더링 할 자식 라우트를 지정한다.

![index 라우트](../src/images/index-route.png)

<br />

### 에러 처리 전용 라우트

- 라우팅 과정에서 발생하는 문제를 사용자에게 적절한 화면으로 보여주기 위한 라우트 처리 방식이다.

- 에러는 크게 두 종류로 나뉜다.
  
  - 경로가 없는 경우 (URL 자체가 틀림)

  - 라우트는 맞는데 처리 중 문제가 발생한 경우 (데이터 로딩, 액션 실패 등)

#### 404 라우트 (Not Found)

#### 404 라우트 (Not Found)




<br />
<br />




## 리액트 라우터가 제공하는 주요 훅