# Context API

- [Context API란](#context-api란)
  - [Props의 단점](#props의-단점)
  - [Context API의 장점](#context-api의-장점)
- [Context API 사용 방법](#context-api-사용-방법)
  - [Context 객체 생성](#context-객체-생성)
  - [Provider 컴포넌트를 만들어서 export](#provider-컴포넌트를-만들어서-export)
  - [자식 컴포넌트에 Context 제공](#자식-컴포넌트에-context-제공)
  - [자식 컴포넌트에서 Context 사용 (useContext)](#자식-컴포넌트에서-context-사용-usecontext)
  - [자식 컴포넌트에서 Context 사용 (use)](#자식-컴포넌트에서-context-사용-use)
- [Context API의 한계](#context-api의-한계)




<br />
<br />




## Context API란

### Props의 단점

- `Props`는 부모에서 자식으로 데이터가 전달되는 단방향 흐름이다.

- 컴포넌트가 깊어질수록 `Props Drilling`이 발생한다.
  
  - 실제로 필요 없는 중간 컴포넌트들도 `Props`를 받아서 다시 넘겨야 한다.

  ![Props Drilling](../src/images/props-drilling.png)

- 여러 컴포넌트가 상태를 공유해야 한다면, 공통의 부모 컴포넌트에서 상태를 관리해야 한다.

  ![Props Draw](../src/images/props-draw.png)

  - `Props`는 각 하위 컴포넌트에서만 사용되고 공유하지 못한다.

  - 상태 변경 함수에 의해 상태 값이 바뀌어야 하므로 공통의 부모 컴포넌트로 끌어올려서 관리해야 한다.

- 데이터 변경 시 중간 컴포넌트들이 불필요하게 리렌더링되는 문제가 발생한다.

  ![Props Rerendering](../src/images/props-rerendering.png)

<br />

### Context API의 장점

- `Props`를 중간 단계에서 계속 전달하지 않고, 전역처럼 데이터를 효율적으로 전달하기 위해 리액트에서 기본으로 제공하는 `API`이다.

- 필요한 데이터를 어디서든 바로 꺼내 쓸 수 있어 불필요한 리렌더링과 코드 복잡성을 줄일 수 있다.

- Context API는 상태 저장 공간만 제공할 뿐, 자체적인 상태 관리나 복잡한 로직 처리 기능은 없다.
  
  - 복잡한 상태 관리가 필요하면 `Redux`, `Zustand` 같은 전역 상태 관리 라이브러리가 더 적합하다.




<br />
<br />




## Context API 사용 방법

### Context 객체 생성

```tsx
// CounterContext.tsx
import { createContext } from "react";

interface CounterContextType {
  count: number;
  countUp: (step: number) => void;
  reset: (initValue: number) => void;
  countDown: (step: number) => void;
}

const CounterContext = createContext<CounterContextType | null>(null);
```

- `Context`에 담길 값을 타입으로 정의한다.

- `createContext`함수를 이용해 빈 `Context` 객체를 생성한다.
  
  - `Context`가 최종적으로 제공할 값의 타입도 설정해준다.

- 초기값으로 `null`을 넣어준 이유는 `createContext`를 호출하는 순간에는 아직 값이 없기 때문이다.
  
  - `Provider` 안에서만 만들어진다.

<br />

### Provider 컴포넌트를 만들어서 export

```tsx
// CounterContext.tsx
export function CounterProvider({ children }: { children: React.ReactNode }) {
  const [ count, setCount ] = useState(10);

  const countUp = (step: number) => {
    setCount(count + step);
  };

  const reset = (initValue: number) => {
    setCount(initValue);
  };

  const countDown = (step: number) => {
    setCount(count - step);
  };
  
  const context = { count, countUp, reset, countDown };

  return (
    <CounterContext value={ context }>
      { children }
    </CounterContext>
  );
}
```

- 상태와 상태 변경 함수를 관리할 컴포넌트를 작성한다.

- `CounterProvider` 컴포넌트에 의해 새로운 `Provider` 컴포넌트가 만들어지며, 

  - `Context`를 제공받아 하위의 모든 컴포넌트에서 사용할 수 있다.

<br />

### 자식 컴포넌트에 Context 제공

![Context API](../src/images/context-api.png)

- `CounterProvider` 컴포넌트를 부모로 하고, 자식으로 넣을 컴포넌트를 지정한다.

- 빈 객체인 `CounterContext`의 `value`에 데이터를 담아서 `Context.Provider` 컴포넌트를 생성한다.
  
  - 자식과 하위의 모든 자손 컴포넌트는 `Context`를 제공받아 값을 사용할 수 있게된다.

  ![Context Provider](../src/images/context-provider.png)

<br />

### 자식 컴포넌트에서 Context 사용 (useContext)

- `useContext(CounterContext)`는 `Provider(CounterContext)`의 `value`에 전달된 객체를 그대로 반환한다.

  ![Context Children](../src/images/context-children.png)

- `useContext(CounterContext)`를 호출하면 해당 컴포넌트가 `Context`를 구독한다.
  
  - `Context` 값 변경 시, 구독한 컴포넌트만 리렌더링된다.

  ![Context Rendering](../src/images/context-rendering.png)

<br />

### 자식 컴포넌트에서 Context 사용 (use)

- `use` 훅을 사용하여 `Context`를 조건부로 구독하여 사용할 수 있다.

  ![use hook - 1](../src/images/use-hook-1.png)

  - 컴포넌트를 생성할 때 기본 값을 `true`로 설정하여 `Context`를 제공 받아 상태값을 사용할 수 있으며 리렌더링 된다.
  
    - `false`로 설정하면 `Context`를 제공받지 못하고 초기 설정된 값을 사용하며 리렌더링 되지 않는다.




<br />
<br />




## Context API의 한계

![Context Api Weakness](../src/images/context-api-weakness.png)